!
! template: frr/bgpd/bgpd.main.conf.j2
!
! bgp multiple-instance
!
! Policies:
{# define dynamic policies #}
{% for name, props in constants.bgp.peers.dynamic.items() %}
{%   if props.enabled %}
{%     include "frr/bgpd/templates/" + name + "/policies.conf.j2" %}
{%   endif %}
{% endfor %}
{# define monitors policies #}
{% for name, props in constants.bgp.peers.monitors.items() %}
{%   if props.enabled %}
{%     include "frr/bgpd/templates/" + name + "/policies.conf.j2" %}
{%   endif %}
{% endfor %}
{# define general policies #}
{% for name, props in constants.bgp.peers.general.items() %}
{%   for peer_type in constants.bgp.levels[DEVICE_METADATA['localhost']['type']] %}
{%     if props.enabled and props.deployment_id == DEVICE_METADATA['localhost']['deployment_id'] | int and props.level == peer_type %}
{%       include "frr/bgpd/templates/" + name + "/policies.conf.j2" %}
{%     endif %}
{%   endfor %}
{% endfor %}
! BGP configuration
router bgp {{ DEVICE_METADATA['localhost']['bgp_asn'] }}
!
{% block bgp_init %}
  bgp log-neighbor-changes
  no bgp default ipv4-unicast
!
{% if constants.bgp.multipath_relax.enabled is defined and constants.bgp.multipath_relax.enabled %}
  bgp bestpath as-path multipath-relax
{% endif %}
!
{% if constants.bgp.graceful_restart.enabled is defined and constants.bgp.graceful_restart.enabled %}
  bgp graceful-restart restart-time {{ constants.bgp.graceful_restart.restart_time | default(240) }}
  bgp graceful-restart
{%   if DEVICE_METADATA['localhost']['type'] == 'ToRRouter' %}
! FIXME: we could make it configurable from bgpcfgd
  bgp graceful-restart preserve-fw-state
{%   endif %}
{% endif %}
!
{# set router-id #}
  bgp router-id {{ get_ipv4_loopback_address(LOOPBACK_INTERFACE, "Loopback0") | ip }}
!
{# advertise loopback #}
  network {{ get_ipv4_loopback_address(LOOPBACK_INTERFACE, "Loopback0") | ip }}/32
!
  address-family ipv6
    network {{ get_ipv6_loopback_address(LOOPBACK_INTERFACE, "Loopback0") | ip }}/64
  exit-address-family
{% endblock bgp_init %}
!
{% block vlan_advertisement %}
{% for (name, prefix) in VLAN_INTERFACE|pfx_filter %}
{% if prefix | ipv4 %}
  network {{ prefix }}
{% elif prefix | ipv6 %}
  address-family ipv6
   network {{ prefix }}
  exit-address-family
{% endif %}
{% endfor %}
{% endblock vlan_advertisement %}
!
{% if constants.bgp.maximum_paths.enabled is defined and constants.bgp.maximum_paths.enabled %}
{% block maximum_paths %}
  address-family ipv4
    maximum-paths {{ constants.bgp.maximum_paths.ipv4 | default(64) }}
  exit-address-family
  address-family ipv6
    maximum-paths {{ constants.bgp.maximum_paths.ipv6 | default(64) }}
  exit-address-family
{% endblock maximum_paths %}
{% endif %}
!
! ToDo: Use macro
{# define dynamic peer groups #}
{% for name, props in constants.bgp.peers.dynamic.items() %}
{%   if props.enabled %}
{%     include "frr/bgpd/templates/" + name + "/peer-group.conf.j2" %}
{%   endif %}
{% endfor %}
{# define monitor peer groups #}
{% for name, props in constants.bgp.peers.monitors.items() %}
{%   if props.enabled %}
{%     include "frr/bgpd/templates/" + name + "/peer-group.conf.j2" %}
{%   endif %}
{% endfor %}
{# define general peer groups #}
{% for name, props in constants.bgp.peers.general.items() %}
{%   for peer_type in constants.bgp.levels[DEVICE_METADATA['localhost']['type']] %}
{%     if props.enabled and props.deployment_id == DEVICE_METADATA['localhost']['deployment_id'] | int and props.level == peer_type %}
{%     include "frr/bgpd/templates/" + name + "/peer-group.conf.j2" %}
{%     endif %}
{%   endfor %}
{% endfor %}
!
! end of template: frr/bgpd/bgpd.main.conf.j2
!
